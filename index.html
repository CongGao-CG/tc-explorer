<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tropical Cyclone Explorer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html,body{height:100%}
    #map{height:100%;width:100%}
    .leaflet-tooltip.tc-label{font-size:10px;font-weight:600;background:rgba(255,255,255,.9);border:none;padding:1px 4px;border-radius:2px;pointer-events:none}
    .grid-line{stroke:#ccc;stroke-width:0.5;stroke-dasharray:2,4;fill:none}
    .grid-label{font-size:11px;fill:#666;font-family:Arial,sans-serif}
  </style>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  </head>
<body class="h-full w-full flex">
  <aside class="w-80 p-4 bg-gray-100 overflow-y-auto">
    <h1 class="text-2xl font-bold mb-4">Tropical Cyclones</h1>
    <input id="search" type="text" placeholder="Search storms…" class="mb-4 w-full p-2 border rounded" />
    <ul id="storm-list" class="space-y-2"></ul>
  </aside>
  <main class="flex-1"><div id="map"></div></main>
  <script>
    /* ---------- Base map ---------- */
    const map=L.map('map').setView([20,0],3);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
      attribution:'© OpenStreetMap contributors',
      maxZoom:19,
      noWrap:false // This enables continuous horizontal scrolling
    }).addTo(map);
    
    /* ---------- Lat/Lon Grid ---------- */
    const gridLayer=L.layerGroup().addTo(map);
    
    function normalizelon(lon){
      // Normalize longitude to -180 to 180 range
      while(lon>180) lon-=360;
      while(lon<-180) lon+=360;
      return lon;
    }
    
    function drawGrid(){
      gridLayer.clearLayers();
      const bounds=map.getBounds();
      const zoom=map.getZoom();
      
      let step=30;
      if(zoom>3) step=20; if(zoom>5) step=10; if(zoom>7) step=5;
      if(zoom>9) step=2; if(zoom>11) step=1;
      
      const west=bounds.getWest(); const east=bounds.getEast();
      const south=Math.max(-85,bounds.getSouth()); const north=Math.min(85,bounds.getNorth());
      
      for(let lat=-90;lat<=90;lat+=step){
        if(lat<south-step||lat>north+step) continue;
        gridLayer.addLayer(L.polyline([[lat,west],[lat,east]],{color:'#999',weight:1,opacity:0.5,dashArray:'2,4',interactive:false}));
        const startLng=Math.floor(west/60)*60;
        for(let lng=startLng;lng<=east;lng+=60){
          const label=L.divIcon({html:`<div style="font-size:11px;color:#666;background:rgba(255,255,255,0.9);padding:2px 4px;border-radius:2px;border:1px solid #ddd">${lat}°</div>`,iconSize:[40,16],iconAnchor:[0,8],className:''});
          gridLayer.addLayer(L.marker([lat,lng],{icon:label,interactive:false}));
        }
      }
      
      const startLng=Math.floor(west/step)*step; const endLng=Math.ceil(east/step)*step;
      for(let lng=startLng;lng<=endLng;lng+=step){
        gridLayer.addLayer(L.polyline([[south,lng],[north,lng]],{color:'#999',weight:1,opacity:0.5,dashArray:'2,4',interactive:false}));
        const normLng=normalizelon(lng);
        const label=L.divIcon({html:`<div style="font-size:11px;color:#666;background:rgba(255,255,255,0.9);padding:2px 4px;border-radius:2px;border:1px solid #ddd">${normLng}°</div>`,iconSize:[40,16],iconAnchor:[20,0],className:''});
        gridLayer.addLayer(L.marker([north-2,lng],{icon:label,interactive:false}));
      }
    }
    
    map.on('moveend zoomend',drawGrid);
    setTimeout(drawGrid,100);
    
    let currentLayer=null;
    let catalogue=[];
    /* ---------- Load catalogue ---------- */
    fetch('storms/storms.json')
      .then(r=>r.ok?r.json():Promise.reject(r.status))
      .then(data=>{catalogue=data;renderList(data,true);})
      .catch(code=>alert(`storms.json error – HTTP ${code}`));
    const listEl=document.getElementById('storm-list');
    const searchEl=document.getElementById('search');

    /* ---------- Render list ---------- */
    function renderList(arr,sortByYearDesc=false){
      const sorted=arr.slice().sort((a,b)=>{
        if(sortByYearDesc){
          const yr=b.year-a.year; if(yr!==0) return yr;
        }
        return a.id.localeCompare(b.id);
      });
      listEl.innerHTML='';
      sorted.forEach(s=>{
        const li=document.createElement('li');
        li.className='cursor-pointer hover:bg-blue-100 p-2 rounded';
        li.textContent=`${s.id} – ${s.name||'Unnamed'} (${s.year})`;
        li.onclick=()=>loadStorm(s);
        listEl.appendChild(li);
      });
    }
    /* ---------- Search ---------- */
    searchEl.oninput=e=>{
      const q=e.target.value.trim().toLowerCase();
      if(!q){ renderList(catalogue,true); return; }
      const filtered=catalogue.filter(s=>
        s.id.toLowerCase().includes(q)||
        (s.name && s.name.toLowerCase().includes(q))||
        String(s.year).includes(q)
      );
      renderList(filtered,false);
    };

    /**
     * Parses a KML coordinate string and "unwraps" the longitudes
     * to allow them to cross the 180° meridian properly.
     * @param {string} coordsStr - The string of coordinates from the KML file.
     * @returns {Array<[number, number]>} An array of [lat, lon] pairs.
     */
    function parseAndUnwrapCoordinates(coordsStr) {
        const points = coordsStr.split(/\s+/).filter(p => p);
        let lastLon = null;
        return points.map(p => {
            const [lon, lat] = p.split(',').map(Number);
            let currentLon = lon;
            if (lastLon !== null) {
                // If the longitude jump is > 180°, it crossed the date line
                if (Math.abs(currentLon - lastLon) > 180) {
                    currentLon += (currentLon > lastLon) ? -360 : 360;
                }
            }
            lastLon = currentLon;
            return [lat, currentLon]; // Leaflet expects [lat, lon]
        });
    }
    
    /* ---------- Load storm (NEW ASYNC VERSION) ---------- */
    async function loadStorm(storm) {
      if (currentLayer) map.removeLayer(currentLayer);
    
      try {
        // 1. Fetch the KML file as text
        const response = await fetch(storm.kml);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const kmlText = await response.text();
    
        // 2. Parse the text into an XML document
        const parser = new DOMParser();
        const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
    
        // 3. Create a FeatureGroup to hold all layers for this storm
        const stormLayerGroup = L.featureGroup();
    
        // 4. Find and draw the storm track (LineString)
        const linePlacemarks = kmlDoc.querySelectorAll('Placemark > LineString');
        linePlacemarks.forEach(lineString => {
          const coordsStr = lineString.querySelector('coordinates').textContent.trim();
          const latlngs = parseAndUnwrapCoordinates(coordsStr);
          const track = L.polyline(latlngs, {
            color: '#4A90E2',
            weight: 3,
            opacity: 0.9
          });
          stormLayerGroup.addLayer(track);
        });

        // 5. Find and draw the labels (Points)
        const pointPlacemarks = kmlDoc.querySelectorAll('Placemark > Point');
        pointPlacemarks.forEach(pointPlacemark => {
            const parent = pointPlacemark.parentElement;
            const name = parent.querySelector('name')?.textContent || '';
            if (!name) return;

            const coordsStr = pointPlacemark.querySelector('coordinates').textContent.trim();
            const [lon, lat] = coordsStr.split(',').map(Number);
            
            // Create a small, invisible marker to anchor the label
            const marker = L.circleMarker([lat, lon], { radius: 0, opacity: 0 });
            marker.bindTooltip(name, {
                permanent: true,
                direction: 'right',
                className: 'tc-label',
                offset: [6, 0]
            });
            stormLayerGroup.addLayer(marker);
        });
    
        // 6. Add the completed layer group to the map
        currentLayer = stormLayerGroup;
        map.addLayer(currentLayer);
    
        // 7. Zoom to fit the new storm track
        if (currentLayer.getLayers().length > 0) {
          map.fitBounds(currentLayer.getBounds());
        }
      } catch (error) {
        console.error("Failed to load storm:", error);
        alert(`Could not load storm data for ${storm.name}. See console for details.`);
      }
    }
  </script>
</body>
</html>
