<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tropical Cyclone Explorer</title>

  <!-- Tailwind & Leaflet assets -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" rel="stylesheet" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-plugins@3.0.0/layer/vector/KML.min.js"></script>

  <style>
    html,body{height:100%}
    #map{height:100%;width:100%}
    .leaflet-tooltip.tc-label{
      font-size:10px;font-weight:600;
      background:rgba(255,255,255,.9);
      border:none;padding:1px 4px;border-radius:2px;
      pointer-events:none
    }
  </style>
</head>

<body class="h-full w-full flex">
  <!-- ---------- Sidebar ---------- -->
  <aside class="w-80 p-4 bg-gray-100 overflow-y-auto">
    <h1 class="text-2xl font-bold mb-4">Tropical Cyclones</h1>
    <input id="search" type="text" placeholder="Search storms…" class="mb-4 w-full p-2 border rounded" />
    <ul id="storm-list" class="space-y-2"></ul>
  </aside>

  <!-- ---------- Map ---------- -->
  <main class="flex-1"><div id="map"></div></main>

  <script>
  /* ------------------------------------------------------------------ */
  /*  Base map (with horizontal wrap)                                   */
  /* ------------------------------------------------------------------ */
  const map = L.map('map').setView([20, 0], 3);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution : '© OpenStreetMap contributors',
    maxZoom     : 19,
    noWrap      : false                  // allow infinite horizontal panning
  }).addTo(map);

  /* ------------------------------------------------------------------ */
  /*  Lat/Lon grid (simple – no changes from previous version)          */
  /* ------------------------------------------------------------------ */
  const gridLayer = L.layerGroup().addTo(map);

  function normalizelon(lon){
    while (lon >  180) lon -= 360;
    while (lon < -180) lon += 360;
    return lon;
  }

  function drawGrid(){
    gridLayer.clearLayers();
    const b   = map.getBounds(),
          z   = map.getZoom();

    let step = 30;            // coarse grid – refine by zoom
    if (z>3)  step = 20;
    if (z>5)  step = 10;
    if (z>7)  step = 5;
    if (z>9)  step = 2;
    if (z>11) step = 1;

    const W=b.getWest(), E=b.getEast(),
          S=Math.max(-85,b.getSouth()),
          N=Math.min( 85,b.getNorth());

    // latitude lines
    for (let lat=-90; lat<=90; lat+=step){
      if (lat<S-step || lat>N+step) continue;

      gridLayer.addLayer(L.polyline([[lat,W],[lat,E]],{
        color:'#999', weight:1, opacity:.5, dashArray:'2,4', interactive:false
      }));

      const startLng=Math.floor(W/60)*60;
      for (let lng=startLng; lng<=E; lng+=60){
        gridLayer.addLayer(L.marker([lat,lng],{
          interactive:false,
          icon:L.divIcon({
            html:`<div style="font-size:11px;color:#666;background:rgba(255,255,255,0.9);padding:2px 4px;border-radius:2px;border:1px solid #ddd">${lat}°</div>`,
            iconSize:[40,16], iconAnchor:[0,8], className:''
          })
        }));
      }
    }

    // longitude lines
    const startLng=Math.floor(W/step)*step,
          endLng  =Math.ceil (E/step)*step;

    for (let lng=startLng; lng<=endLng; lng+=step){
      gridLayer.addLayer(L.polyline([[S,lng],[N,lng]],{
        color:'#999', weight:1, opacity:.5, dashArray:'2,4', interactive:false
      }));

      const norm = normalizelon(lng);
      gridLayer.addLayer(L.marker([N-2,lng],{
        interactive:false,
        icon:L.divIcon({
          html:`<div style="font-size:11px;color:#666;background:rgba(255,255,255,0.9);padding:2px 4px;border-radius:2px;border:1px solid #ddd">${norm}°</div>`,
          iconSize:[40,16], iconAnchor:[20,0], className:''
        })
      }));
    }
  }

  map.on('moveend zoomend', drawGrid);
  setTimeout(drawGrid, 100);   // initial draw

  /* ------------------------------------------------------------------ */
  /*  Storm catalogue & sidebar                                         */
  /* ------------------------------------------------------------------ */
  let currentLayer = null,
      catalogue    = [];

  fetch('storms/storms.json')
    .then(r => r.ok ? r.json() : Promise.reject(r.status))
    .then(d => { catalogue = d; renderList(d,true); })
    .catch(code => alert(`storms.json error – HTTP ${code}`));

  const listEl   = document.getElementById('storm-list'),
        searchEl = document.getElementById('search');

  function renderList(arr,sortByYearDesc=false){
    const sorted = arr.slice().sort((a,b)=>{
      if (sortByYearDesc){
        const yr=b.year-a.year; if(yr) return yr;
      }
      return a.id.localeCompare(b.id);
    });

    listEl.innerHTML='';
    sorted.forEach(s=>{
      const li=document.createElement('li');
      li.className='cursor-pointer hover:bg-blue-100 p-2 rounded';
      li.textContent=`${s.id} – ${s.name||'Unnamed'} (${s.year})`;
      li.onclick=()=>loadStorm(s);
      listEl.appendChild(li);
    });
  }

  searchEl.oninput=e=>{
    const q=e.target.value.trim().toLowerCase();
    if(!q){ renderList(catalogue,true); return; }
    renderList(
      catalogue.filter(s=>
        s.id.toLowerCase().includes(q) ||
        (s.name && s.name.toLowerCase().includes(q)) ||
        String(s.year).includes(q)
      ), false
    );
  };

  /* ------------------------------------------------------------------ */
  /*  Dateline-safe polyline handling                                   */
  /* ------------------------------------------------------------------ */
  /** “Unwrap” a sequence of LatLngs so the path never jumps >180°.       *
   *  Returns a *flat* array, safe for L.Polyline.setLatLngs().          */
  function unwrapLatLngs(latlngs){
    const flat = L.LineUtil.isFlat(latlngs) ? latlngs
                 : latlngs.flat(Infinity);          // polygons → outer ring
    const out  = [];
    let offset = 0;

    for (let i=0;i<flat.length;i++){
      let {lat,lng} = flat[i];

      // keep continuity: if Δλ > 180°, shift subsequent points ±360°
      if (i){
        const prev = out[i-1].lng;
        const diff = lng + offset - prev;

        if (diff > 180)  offset -= 360;
        if (diff < -180) offset += 360;
      }
      out.push(L.latLng(lat, lng + offset));
    }
    return out;
  }

  /** Recursively fix every polyline / polygon in a layer group */
  function fixDateline(layer){
    if (layer instanceof L.Polyline){
      layer.setLatLngs( unwrapLatLngs(layer.getLatLngs()) );
      return;
    }
    if (layer.eachLayer) layer.eachLayer(fixDateline);
  }

  /* ------------------------------------------------------------------ */
  /*  Load & display a single storm                                     */
  /* ------------------------------------------------------------------ */
  function loadStorm(storm){
    if (currentLayer) map.removeLayer(currentLayer);

    currentLayer = new L.KML(storm.kml,{async:true});
    currentLayer.on('loaded',()=>{
      fixDateline(currentLayer);              // <<< key line for Date Line
      addLabelsRecursive(currentLayer);

      // Fit view – normalise centre longitude to −180…180 so the map
      // recentres on the “main” world copy.
      const b     = currentLayer.getBounds();
      const c     = b.getCenter();
      const normC = L.latLng(c.lat, normalizelon(c.lng));
      map.fitBounds(b);
      map.panTo(normC);                       // avoid off-centre wrap
    });

    map.addLayer(currentLayer);
  }

  /* ------------------------------------------------------------------ */
  /*  Labels (unchanged)                                                */
  /* ------------------------------------------------------------------ */
  function addLabelsRecursive(layer){
    if (layer.getLayers) layer.getLayers().forEach(addLabelsRecursive);
    if (typeof layer.bindTooltip !== 'function') return;

    const label = getLabel(layer);
    if (label && !layer.getTooltip())
      layer.bindTooltip(label,{
        permanent:true, direction:'right',
        className:'tc-label', offset:[6,0]
      });
  }

  function getLabel(layer){
    return layer?.feature?.properties?.name
        || layer.options?.title
        || layer.options?.name
        || (layer.getPopup && layer.getPopup()
            ? (layer.getPopup().getContent().match(/<h2>(.*?)<\/h2>/i)||[])[1]
            : '');
  }
  </script>
</body>
</html>
