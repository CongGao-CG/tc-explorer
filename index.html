<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tropical Cyclone Explorer</title>

  <!-- Assets -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" rel="stylesheet" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-plugins@3.0.0/layer/vector/KML.min.js"></script>

  <style>
    html,body{height:100%}
    #map{height:100%;width:100%}
    .leaflet-tooltip.tc-label{
      font-size:10px;font-weight:600;
      background:rgba(255,255,255,.9);
      border:none;padding:1px 4px;border-radius:2px;
      pointer-events:none
    }
  </style>
</head>

<body class="h-full w-full flex">
<!-- ─────────────── Sidebar ─────────────── -->
<aside class="w-80 p-4 bg-gray-100 overflow-y-auto">
  <h1 class="text-2xl font-bold mb-4">Tropical Cyclones</h1>
  <input id="search" type="text" placeholder="Search storms…" class="mb-4 w-full p-2 border rounded" />
  <ul   id="storm-list" class="space-y-2"></ul>
</aside>

<!-- ─────────────── Map ─────────────── -->
<main class="flex-1"><div id="map"></div></main>

<script>
/* ------------------------------------------------------------------ */
/*  Base map                                                          */
/* ------------------------------------------------------------------ */
const map=L.map('map').setView([20,0],3);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
  attribution:'© OpenStreetMap contributors',
  maxZoom:19,
  noWrap:false
}).addTo(map);

/* ------------------------------------------------------------------ */
/*  Lat/Lon grid (unchanged)                                          */
/* ------------------------------------------------------------------ */
const gridLayer=L.layerGroup().addTo(map);
function normLon(l){while(l> 180)l-=360;while(l<-180)l+=360;return l;}
function drawGrid(){
  gridLayer.clearLayers();
  const b=map.getBounds(), z=map.getZoom();
  let step=30;if(z>3)step=20;if(z>5)step=10;if(z>7)step=5;if(z>9)step=2;if(z>11)step=1;
  const W=b.getWest(),E=b.getEast(),S=Math.max(-85,b.getSouth()),N=Math.min(85,b.getNorth());
  for(let lat=-90;lat<=90;lat+=step){
    if(lat<S-step||lat>N+step)continue;
    gridLayer.addLayer(L.polyline([[lat,W],[lat,E]],{color:'#999',weight:1,opacity:.5,dashArray:'2,4',interactive:false}));
    const startLng=Math.floor(W/60)*60;
    for(let lng=startLng;lng<=E;lng+=60){
      gridLayer.addLayer(L.marker([lat,lng],{interactive:false,
        icon:L.divIcon({html:`<div style="font-size:11px;color:#666;background:rgba(255,255,255,0.9);padding:2px 4px;border-radius:2px;border:1px solid #ddd">${lat}°</div>`,
        iconSize:[40,16],iconAnchor:[0,8],className:''})}));
    }
  }
  const startLng=Math.floor(W/step)*step,endLng=Math.ceil(E/step)*step;
  for(let lng=startLng;lng<=endLng;lng+=step){
    gridLayer.addLayer(L.polyline([[S,lng],[N,lng]],{color:'#999',weight:1,opacity:.5,dashArray:'2,4',interactive:false}));
    gridLayer.addLayer(L.marker([N-2,lng],{interactive:false,
      icon:L.divIcon({html:`<div style="font-size:11px;color:#666;background:rgba(255,255,255,0.9);padding:2px 4px;border-radius:2px;border:1px solid #ddd">${normLon(lng)}°</div>`,
      iconSize:[40,16],iconAnchor:[20,0],className:''})}));
  }
}
map.on('moveend zoomend',drawGrid);setTimeout(drawGrid,100);

/* ------------------------------------------------------------------ */
/*  Sidebar catalogue                                                 */
/* ------------------------------------------------------------------ */
let currentLayer=null,catalogue=[];
fetch('storms/storms.json')
  .then(r=>r.ok?r.json():Promise.reject(r.status))
  .then(d=>{catalogue=d;renderList(d,true);})
  .catch(c=>alert(`storms.json HTTP ${c}`));

const listEl=document.getElementById('storm-list'),searchEl=document.getElementById('search');
function renderList(arr,desc=false){
  const s=arr.slice().sort((a,b)=>{
    if(desc){const y=b.year-a.year;if(y)return y;}
    return a.id.localeCompare(b.id);
  });
  listEl.innerHTML='';
  s.forEach(st=>{
    const li=document.createElement('li');
    li.className='cursor-pointer hover:bg-blue-100 p-2 rounded';
    li.textContent=`${st.id} – ${st.name||'Unnamed'} (${st.year})`;
    li.onclick=()=>loadStorm(st);
    listEl.appendChild(li);
  });
}
searchEl.oninput=e=>{
  const q=e.target.value.trim().toLowerCase();
  if(!q){renderList(catalogue,true);return;}
  renderList(catalogue.filter(s=>
    s.id.toLowerCase().includes(q)||
    (s.name&&s.name.toLowerCase().includes(q))||
    String(s.year).includes(q)
  ),false);
};

/* ------------------------------------------------------------------ */
/*  Antimeridian helpers                                              */
/* ------------------------------------------------------------------ */
/*  1️⃣  Unwrap so successive points differ by <180 °                  */
function unwrapTrack(flat){
  const res=[];let shift=0;
  for(let i=0;i<flat.length;i++){
    let {lat,lng}=flat[i];
    let adjLng=lng+shift;
    if(i){
      const prev=res[res.length-1].lng;
      let d=adjLng-prev;
      if(d> 180){shift-=360;adjLng=lng+shift;}
      if(d<-180){shift+=360;adjLng=lng+shift;}
    }
    res.push(L.latLng(lat,adjLng));
  }
  return res;
}
/*  2️⃣  Bring wrapped longitudes back to main world copy              */
function rewrapForDisplay(unwrapped){
  // choose a single 360°-copy that minimises total span
  const longitudes=unwrapped.map(p=>p.lng);
  const centre=(Math.min(...longitudes)+Math.max(...longitudes))/2;
  const k=Math.round(centre/360);          // which 360° band
  return unwrapped.map(p=>L.latLng(p.lat,p.lng-360*k));
}

/*  3️⃣  Apply to every polyline                                       */
function fixDateline(layer){
  if(layer instanceof L.Polyline && !(layer instanceof L.Polygon)){
    const flat=L.LineUtil.isFlat(layer.getLatLngs())
               ?layer.getLatLngs()
               :layer.getLatLngs().flat(Infinity);
    const fixed=rewrapForDisplay(unwrapTrack(flat));
    layer.setLatLngs(fixed);
    layer.setStyle({noClip:true});         // avoid Leaflet’s hard-edge clip
    return;
  }
  if(layer.eachLayer) layer.eachLayer(fixDateline);
}

/* ------------------------------------------------------------------ */
/*  Load one storm                                                    */
/* ------------------------------------------------------------------ */
function loadStorm(storm){
  if(currentLayer) map.removeLayer(currentLayer);
  currentLayer=new L.KML(storm.kml,{async:true});
  currentLayer.on('loaded',()=>{
    fixDateline(currentLayer);
    addLabelsRecursive(currentLayer);
    map.fitBounds(currentLayer.getBounds(),{padding:[20,20]});
  });
  map.addLayer(currentLayer);
}

/* ------------------------------------------------------------------ */
/*  Labels (unchanged)                                                */
/* ------------------------------------------------------------------ */
function addLabelsRecursive(layer){
  if(layer.getLayers)layer.getLayers().forEach(addLabelsRecursive);
  if(typeof layer.bindTooltip!=='function')return;
  const lbl=getLabel(layer);
  if(lbl&&!layer.getTooltip())layer.bindTooltip(lbl,{permanent:true,direction:'right',
                  className:'tc-label',offset:[6,0]});
}
function getLabel(layer){
  return layer?.feature?.properties?.name
      || layer.options?.title
      || layer.options?.name
      || (layer.getPopup&&layer.getPopup()
          ?(layer.getPopup().getContent().match(/<h2>(.*?)<\/h2>/i)||[])[1]
          :'');
}
</script>
</body>
</html>
