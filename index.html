<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tropical Cyclone Explorer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.2.1/ol.css">
  <script src="https://cdn.jsdelivr.net/npm/ol@v10.2.1/dist/ol.js"></script>
  <style>
    html,body{height:100%}
    #map{height:100%;width:100%}
    .ol-tooltip{position:absolute;background:rgba(255,255,255,.9);border:none;padding:1px 4px;border-radius:2px;font-size:10px;font-weight:600;pointer-events:none;white-space:nowrap}
    .ol-popup{position:absolute;background-color:white;box-shadow:0 1px 4px rgba(0,0,0,0.2);padding:15px;border-radius:10px;border:1px solid #cccccc;bottom:12px;left:-50px;min-width:150px}
    .ol-popup:after,.ol-popup:before{top:100%;border:solid transparent;content:" ";height:0;width:0;position:absolute;pointer-events:none}
    .ol-popup:after{border-top-color:white;border-width:10px;left:48px;margin-left:-10px}
    .ol-popup:before{border-top-color:#cccccc;border-width:11px;left:48px;margin-left:-11px}
    .ol-popup-closer{text-decoration:none;position:absolute;top:2px;right:8px}
    .ol-popup-closer:after{content:"✖"}
  </style>
</head>
<body class="h-full w-full flex">
  <aside class="w-80 p-4 bg-gray-100 overflow-y-auto">
    <h1 class="text-2xl font-bold mb-4">Tropical Cyclones</h1>
    <input id="search" type="text" placeholder="Search storms…" class="mb-4 w-full p-2 border rounded" />
    <ul id="storm-list" class="space-y-2"></ul>
  </aside>
  <main class="flex-1"><div id="map"></div></main>
  <script>
    /* ---------- Base map ---------- */
    const map = new ol.Map({
      target: 'map',
      layers: [new ol.layer.Tile({source: new ol.source.OSM()})],
      view: new ol.View({center: ol.proj.fromLonLat([0, 20]), zoom: 3})
    });

    let currentLayer = null;
    let currentOverlays = [];
    let catalogue = [];

    /* ---------- Load catalogue ---------- */
    fetch('storms/storms.json')
      .then(r => r.ok ? r.json() : Promise.reject(r.status))
      .then(data => { catalogue = data; renderList(data, true); })
      .catch(code => alert(`storms.json error – HTTP ${code}`));

    const listEl   = document.getElementById('storm-list');
    const searchEl = document.getElementById('search');

    /* ---------- Render list ---------- */
    function renderList(arr, sortByYearDesc = false) {
      const sorted = arr.slice().sort((a, b) => {
        if (sortByYearDesc) {
          const yr = b.year - a.year; if (yr !== 0) return yr;
        }
        return a.id.localeCompare(b.id);
      });
      listEl.innerHTML = '';
      sorted.forEach(s => {
        const li = document.createElement('li');
        li.className = 'cursor-pointer hover:bg-blue-100 p-2 rounded';
        li.textContent = `${s.id} – ${s.name || 'Unnamed'} (${s.year})`;
        li.onclick = () => loadStorm(s);
        listEl.appendChild(li);
      });
    }

    /* ---------- Search ---------- */
    searchEl.oninput = e => {
      const q = e.target.value.trim().toLowerCase();
      if (!q) { renderList(catalogue, true); return; }
      const filtered = catalogue.filter(s =>
        s.id.toLowerCase().includes(q) ||
        (s.name && s.name.toLowerCase().includes(q)) ||
        String(s.year).includes(q)
      );
      renderList(filtered, false);
    };

    /* ---------- Dateline-aware extent helper ---------- */
    function getDatelineSafeExtent(source) {
      const features = source.getFeatures();
      if (!features.length) return null;

      // Extract all coordinates in lon/lat
      let lons = [], lats = [];
      features.forEach(f => {
        const geom = f.getGeometry().clone().transform('EPSG:3857', 'EPSG:4326');
        const type = geom.getType();
        if (type === 'LineString') {
          geom.getCoordinates().forEach(c => { lons.push(c[0]); lats.push(c[1]); });
        } else if (type === 'Point') {
          const c = geom.getCoordinates(); lons.push(c[0]); lats.push(c[1]);
        }
      });
      if (!lons.length) return null;

      // Detect dateline crossing (span > 180°)
      const minLon = Math.min(...lons);
      const maxLon = Math.max(...lons);

      let adjLon = lons;
      if (maxLon - minLon > 180) {
        // Shift all longitudes into a 0-360 domain to collapse the span
        adjLon = lons.map(lon => (lon < 0 ? lon + 360 : lon));
      }

      const minLat = Math.min(...lats);
      const maxLat = Math.max(...lats);
      const minAdj = Math.min(...adjLon);
      const maxAdj = Math.max(...adjLon);

      // Convert back to Web Mercator extent for fit()
      const bl = ol.proj.fromLonLat([minAdj, minLat]);
      const tr = ol.proj.fromLonLat([maxAdj, maxLat]);
      return [bl[0], bl[1], tr[0], tr[1]];
    }

    /* ---------- Load storm ---------- */
    function loadStorm(storm) {
      // Remove existing layer and overlays
      if (currentLayer) map.removeLayer(currentLayer);
      currentOverlays.forEach(o => map.removeOverlay(o));
      currentOverlays = [];

      // Load KML – disable wrapX so OL doesn’t duplicate the geometry around the globe
      const kmlSource = new ol.source.Vector({
        url: storm.kml,
        format: new ol.format.KML(),
        wrapX: false
      });

      currentLayer = new ol.layer.Vector({
        source: kmlSource,
        style: feature => {
          const styles = [];
          if (feature.getGeometry().getType() === 'LineString') {
            styles.push(new ol.style.Style({
              stroke: new ol.style.Stroke({color:'#ff0000',width:2})
            }));
          }
          if (feature.getGeometry().getType() === 'Point') {
            styles.push(new ol.style.Style({
              image: new ol.style.Circle({radius:4,fill:new ol.style.Fill({color:'#ff0000'}),stroke:new ol.style.Stroke({color:'#ffffff',width:1})})
            }));
          }
          return styles;
        }
      });
      map.addLayer(currentLayer);

      // Fit view once the KML is ready
      kmlSource.once('change', () => {
        if (kmlSource.getState() !== 'ready') return;
        const fitExtent = getDatelineSafeExtent(kmlSource) || kmlSource.getExtent();
        if (fitExtent) {
          map.getView().fit(fitExtent, {padding:[50,50,50,50],duration:500});
        }
      });
    }

    /* ---------- Popup for feature info ---------- */
    const popupElement   = document.createElement('div'); popupElement.className = 'ol-popup';
    const popupCloser    = document.createElement('a');  popupCloser.className = 'ol-popup-closer'; popupCloser.href = '#';
    const popupContent   = document.createElement('div');
    popupElement.appendChild(popupCloser); popupElement.appendChild(popupContent);

    const popup = new ol.Overlay({element: popupElement, autoPan:true, autoPanAnimation:{duration:250}});
    map.addOverlay(popup);
    popupCloser.onclick = () => { popup.setPosition(undefined); popupCloser.blur(); return false; };

    map.on('click', evt => {
      const feature = map.forEachFeatureAtPixel(evt.pixel, f => f);
      if (feature) {
        const properties = feature.getProperties();
        let content = '';
        if (properties.name)        content += `<h2 style="margin:0 0 5px 0;font-size:14px">${properties.name}</h2>`;
        if (properties.description) content += `<div style="font-size:12px">${properties.description}</div>`;
        if (content) { popupContent.innerHTML = content; popup.setPosition(evt.coordinate); }
      } else {
        popup.setPosition(undefined);
      }
    });

    map.on('pointermove', evt => {
      map.getTargetElement().style.cursor = map.hasFeatureAtPixel(evt.pixel) ? 'pointer' : '';
    });
  </script>
</body>
</html>
