<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tropical Cyclone Explorer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.2.1/ol.css">
  <script src="https://cdn.jsdelivr.net/npm/ol@v10.2.1/dist/ol.js"></script>
  <style>
    html,body{height:100%}
    #map{height:100%;width:100%}
    .ol-tooltip{position:absolute;background:rgba(255,255,255,.9);border:none;padding:1px 4px;border-radius:2px;font-size:10px;font-weight:600;pointer-events:none;white-space:nowrap}
    .ol-popup{position:absolute;background-color:white;box-shadow:0 1px 4px rgba(0,0,0,0.2);padding:15px;border-radius:10px;border:1px solid #cccccc;bottom:12px;left:-50px;min-width:150px}
    .ol-popup:after,.ol-popup:before{top:100%;border:solid transparent;content:" ";height:0;width:0;position:absolute;pointer-events:none}
    .ol-popup:after{border-top-color:white;border-width:10px;left:48px;margin-left:-10px}
    .ol-popup:before{border-top-color:#cccccc;border-width:11px;left:48px;margin-left:-11px}
    .ol-popup-closer{text-decoration:none;position:absolute;top:2px;right:8px}
    .ol-popup-closer:after{content:"✖"}
  </style>
</head>
<body class="h-full w-full flex">
  <aside class="w-80 p-4 bg-gray-100 overflow-y-auto">
    <h1 class="text-2xl font-bold mb-4">Tropical Cyclones</h1>
    <input id="search" type="text" placeholder="Search storms…" class="mb-4 w-full p-2 border rounded" />
    <ul id="storm-list" class="space-y-2"></ul>
  </aside>
  <main class="flex-1"><div id="map"></div></main>
  <script>
    /* ---------- Base map ---------- */
    const map = new ol.Map({
      target: 'map',
      layers: [
        new ol.layer.Tile({
          source: new ol.source.OSM()
        })
      ],
      view: new ol.View({
        center: ol.proj.fromLonLat([0, 20]),
        zoom: 3
      })
    });

    let currentLayer = null;
    let currentOverlays = [];
    let catalogue = [];

    /* ---------- Load catalogue ---------- */
    fetch('storms/storms.json')
      .then(r => r.ok ? r.json() : Promise.reject(r.status))
      .then(data => {
        catalogue = data;
        renderList(data, true);
      })
      .catch(code => alert(`storms.json error – HTTP ${code}`));

    const listEl = document.getElementById('storm-list');
    const searchEl = document.getElementById('search');

    /* ---------- Render list ---------- */
    function renderList(arr, sortByYearDesc = false) {
      const sorted = arr.slice().sort((a, b) => {
        if (sortByYearDesc) {
          const yr = b.year - a.year;
          if (yr !== 0) return yr;
        }
        return a.id.localeCompare(b.id);
      });
      listEl.innerHTML = '';
      sorted.forEach(s => {
        const li = document.createElement('li');
        li.className = 'cursor-pointer hover:bg-blue-100 p-2 rounded';
        li.textContent = `${s.id} – ${s.name || 'Unnamed'} (${s.year})`;
        li.onclick = () => loadStorm(s);
        listEl.appendChild(li);
      });
    }

    /* ---------- Search ---------- */
    searchEl.oninput = e => {
      const q = e.target.value.trim().toLowerCase();
      if (!q) {
        renderList(catalogue, true);
        return;
      }
      const filtered = catalogue.filter(s =>
        s.id.toLowerCase().includes(q) ||
        (s.name && s.name.toLowerCase().includes(q)) ||
        String(s.year).includes(q)
      );
      renderList(filtered, false);
    };

    /* ---------- Load storm ---------- */
   /* ---------- Load storm ---------- */
   function loadStorm(storm) {
     // Remove existing layer and overlays
     if (currentLayer) {
       map.removeLayer(currentLayer);
     }
     currentOverlays.forEach(overlay => map.removeOverlay(overlay));
     currentOverlays = [];

     // Load KML with wrapX: false
     const kmlSource = new ol.source.Vector({
       url: storm.kml,
       format: new ol.format.KML(),
       wrapX: false
     });

     currentLayer = new ol.layer.Vector({
       source: kmlSource,
       style: function(feature) {
         // This styling function remains the same.
         // It will style the original points and the new line we create.
         const styles = [];
         if (feature.getGeometry().getType() === 'LineString') {
           styles.push(new ol.style.Style({
             stroke: new ol.style.Stroke({ color: '#ff0000', width: 2 })
           }));
         }
         if (feature.getGeometry().getType() === 'Point') {
           styles.push(new ol.style.Style({
             image: new ol.style.Circle({
               radius: 4,
               fill: new ol.style.Fill({ color: '#ff0000' }),
               stroke: new ol.style.Stroke({ color: '#ffffff', width: 1 })
             })
           }));
         }
         return styles;
       }
     });

     map.addLayer(currentLayer);

     // Helper function to parse date/time from KML description
     function extractDate(feature) {
       const description = feature.get('description') || '';
       // Use regex to find date and time strings
       const dateMatch = description.match(/Date:<\/strong>\s*(\d{2}\/\d{2}\/\d{4})/);
       const timeMatch = description.match(/Time:<\/strong>\s*(\d{2}:\d{2})\s*UTC/);

       if (dateMatch && timeMatch) {
         const dateStr = dateMatch[1]; // "MM/DD/YYYY"
         const timeStr = timeMatch[1]; // "HH:mm"
         // Reformat to ISO 8601 for reliable parsing: "YYYY-MM-DDTHH:mm:ssZ"
         const [month, day, year] = dateStr.split('/');
         const isoStr = `${year}-${month}-${day}T${timeStr}:00Z`;
         return new Date(isoStr);
       }
       // Return an early date as a fallback if parsing fails
       return new Date(0);
     }

     // When features are loaded, sort points, create a line, and fit the view
     kmlSource.once('change', () => {
       if (kmlSource.getState() === 'ready') {
         const worldWidth = ol.extent.getWidth(map.getView().getProjection().getExtent());
         
         // 1. Get all features (which are all points) and sort them by date
         const pointFeatures = kmlSource.getFeatures();
         pointFeatures.sort((a, b) => extractDate(a) - extractDate(b));
         
         if (pointFeatures.length > 1) {
           // 2. Create a continuous coordinate array from the sorted points
           const coords = pointFeatures.map(p => p.getGeometry().getCoordinates());
           for (let i = 1; i < coords.length; i++) {
             const prevLon = coords[i-1][0];
             if (Math.abs(coords[i][0] - prevLon) > worldWidth / 2) {
               if (coords[i][0] < prevLon) {
                 coords[i][0] += worldWidth;
               } else {
                 coords[i][0] -= worldWidth;
               }
             }
           }
           
           // 3. Create a new LineString feature from the adjusted coordinates
           const lineGeom = new ol.geom.LineString(coords);
           const lineFeature = new ol.Feature({ geometry: lineGeom });
           // kmlSource.addFeature(lineFeature); // Add the new line to the map
           
           // 4. Adjust original point features to match the new continuous line
           const lineExtent = lineGeom.getExtent();
           const lineCenterLon = (lineExtent[0] + lineExtent[2]) / 2;

           pointFeatures.forEach(point => {
             const pointGeom = point.getGeometry();
             const pCoord = pointGeom.getCoordinates();
             if (Math.abs(pCoord[0] - lineCenterLon) > worldWidth / 2) {
                pCoord[0] += (pCoord[0] < lineCenterLon) ? worldWidth : -worldWidth;
                pointGeom.setCoordinates(pCoord);
             }
           });
         }
         
         // 5. Fit the view to the extent of ALL features (new line + adjusted points)
         const extent = kmlSource.getExtent();
         if (!ol.extent.isEmpty(extent)) {
           map.getView().fit(extent, {
             padding: [50, 50, 50, 50],
             duration: 500
           });
         }
       }
     });
   }

    /* ---------- Popup for feature info ---------- */
    const popupElement = document.createElement('div');
    popupElement.className = 'ol-popup';
    const popupCloser = document.createElement('a');
    popupCloser.className = 'ol-popup-closer';
    popupCloser.href = '#';
    const popupContent = document.createElement('div');
    popupElement.appendChild(popupCloser);
    popupElement.appendChild(popupContent);

    const popup = new ol.Overlay({
      element: popupElement,
      autoPan: true,
      autoPanAnimation: {
        duration: 250
      }
    });
    map.addOverlay(popup);

    popupCloser.onclick = function() {
      popup.setPosition(undefined);
      popupCloser.blur();
      return false;
    };

    // Click handler for features
    map.on('click', function(evt) {
      const feature = map.forEachFeatureAtPixel(evt.pixel, function(feature) {
        return feature;
      });
      
      if (feature) {
        const coordinates = evt.coordinate;
        const properties = feature.getProperties();
        let content = '';
        
        if (properties.name) {
          content += `<h2 style="margin:0 0 5px 0;font-size:14px">${properties.name}</h2>`;
        }
        if (properties.description) {
          content += `<div style="font-size:12px">${properties.description}</div>`;
        }
        
        if (content) {
          popupContent.innerHTML = content;
          popup.setPosition(coordinates);
        }
      } else {
        popup.setPosition(undefined);
      }
    });

    // Change cursor on hover
    map.on('pointermove', function(evt) {
      const pixel = map.getEventPixel(evt.originalEvent);
      const hit = map.hasFeatureAtPixel(pixel);
      map.getTarget().style.cursor = hit ? 'pointer' : '';
    });
  </script>
</body>
</html>
