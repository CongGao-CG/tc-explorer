<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tropical Cyclone Explorer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html,body{height:100%}
    #map{height:100%;width:100%}
    .leaflet-tooltip.tc-label{font-size:10px;font-weight:600;background:rgba(255,255,255,.9);border:none;padding:1px 4px;border-radius:2px;pointer-events:none}
    .grid-line{stroke:#ccc;stroke-width:0.5;stroke-dasharray:2,4;fill:none}
    .grid-label{font-size:11px;fill:#666;font-family:Arial,sans-serif}
  </style>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-plugins@3.0.0/layer/vector/KML.min.js"></script>
</head>
<body class="h-full w-full flex">
  <aside class="w-80 p-4 bg-gray-100 overflow-y-auto">
    <h1 class="text-2xl font-bold mb-4">Tropical Cyclones</h1>
    <input id="search" type="text" placeholder="Search storms…" class="mb-4 w-full p-2 border rounded" />
    <ul id="storm-list" class="space-y-2"></ul>
  </aside>
  <main class="flex-1"><div id="map"></div></main>
  <script>
    /* ---------- Base map with continuous world ---------- */
    const map=L.map('map',{
      worldCopyJump:false,
      maxBounds:[[-90,-Infinity],[90,Infinity]],
      maxBoundsViscosity:1.0
    }).setView([20,0],3);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
      attribution:'© OpenStreetMap contributors',
      maxZoom:19,
      noWrap:false // Allow tiles to repeat horizontally
    }).addTo(map);
    
    /* ---------- Lat/Lon Grid ---------- */
    const gridLayer=L.layerGroup().addTo(map);
    
    function drawGrid(){
      gridLayer.clearLayers();
      const bounds=map.getBounds();
      const zoom=map.getZoom();
      
      // Determine grid spacing based on zoom level
      let step=30;
      if(zoom>3) step=20;
      if(zoom>5) step=10;
      if(zoom>7) step=5;
      if(zoom>9) step=2;
      if(zoom>11) step=1;
      
      // Get visible bounds
      const west=bounds.getWest();
      const east=bounds.getEast();
      const south=Math.max(-85,bounds.getSouth()-step);
      const north=Math.min(85,bounds.getNorth()+step);
      
      // Draw latitude lines
      for(let lat=-90;lat<=90;lat+=step){
        if(lat<south||lat>north) continue;
        const line=L.polyline([[lat,west],[lat,east]],{color:'#999',weight:1,opacity:0.5,dashArray:'2,4',interactive:false});
        gridLayer.addLayer(line);
        
        // Add label at regular intervals across the visible area
        const labelInterval=Math.min(60,Math.max(30,step*3));
        for(let lng=Math.floor(west/labelInterval)*labelInterval;lng<=east;lng+=labelInterval){
          const label=L.divIcon({
            html:`<div style="font-size:11px;color:#666;background:rgba(255,255,255,0.9);padding:2px 4px;border-radius:2px;border:1px solid #ddd">${lat}°</div>`,
            iconSize:[40,16],
            iconAnchor:[0,8],
            className:''
          });
          gridLayer.addLayer(L.marker([lat,lng],{icon:label,interactive:false}));
        }
      }
      
      // Draw longitude lines - normalize to standard -180 to 180 range for display
      for(let baseLng=-180;baseLng<=180;baseLng+=step){
        // Draw multiple copies of each longitude line across the visible area
        for(let worldCopy=Math.floor(west/360);worldCopy<=Math.ceil(east/360);worldCopy++){
          const lng=baseLng+worldCopy*360;
          if(lng<west||lng>east) continue;
          
          const line=L.polyline([[south,lng],[north,lng]],{color:'#999',weight:1,opacity:0.5,dashArray:'2,4',interactive:false});
          gridLayer.addLayer(line);
          
          // Add label showing normalized longitude
          const displayLng=((baseLng+180)%360-180); // Normalize to -180 to 180
          const label=L.divIcon({
            html:`<div style="font-size:11px;color:#666;background:rgba(255,255,255,0.9);padding:2px 4px;border-radius:2px;border:1px solid #ddd">${displayLng}°</div>`,
            iconSize:[40,16],
            iconAnchor:[20,0],
            className:''
          });
          gridLayer.addLayer(L.marker([north-1,lng],{icon:label,interactive:false}));
        }
      }
    }
    
    // Draw grid on map events
    map.on('moveend zoomend',drawGrid);
    drawGrid(); // Initial draw
    
    let currentLayer=null;
    let catalogue=[];
    /* ---------- Load catalogue ---------- */
    fetch('storms/storms.json')
      .then(r=>r.ok?r.json():Promise.reject(r.status))
      .then(data=>{catalogue=data;renderList(data,true);})
      .catch(code=>alert(`storms.json error – HTTP ${code}`));
    const listEl=document.getElementById('storm-list');
    const searchEl=document.getElementById('search');
    /* ---------- Render list ---------- */
    function renderList(arr,sortByYearDesc=false){
      const sorted=arr.slice().sort((a,b)=>{
        if(sortByYearDesc){
          const yr=b.year-a.year; if(yr!==0) return yr;
        }
        return a.id.localeCompare(b.id);
      });
      listEl.innerHTML='';
      sorted.forEach(s=>{
        const li=document.createElement('li');
        li.className='cursor-pointer hover:bg-blue-100 p-2 rounded';
        li.textContent=`${s.id} – ${s.name||'Unnamed'} (${s.year})`;
        li.onclick=()=>loadStorm(s);
        listEl.appendChild(li);
      });
    }
    /* ---------- Search ---------- */
    searchEl.oninput=e=>{
      const q=e.target.value.trim().toLowerCase();
      if(!q){ renderList(catalogue,true); return; }
      const filtered=catalogue.filter(s=>
        s.id.toLowerCase().includes(q)||
        (s.name && s.name.toLowerCase().includes(q))||
        String(s.year).includes(q)
      );
      renderList(filtered,false);
    };
    /* ---------- Load storm ---------- */
    function loadStorm(storm){
      if(currentLayer) map.removeLayer(currentLayer);
      currentLayer=new L.KML(storm.kml,{async:true});
      currentLayer.on('loaded',()=>{addLabelsRecursive(currentLayer);map.fitBounds(currentLayer.getBounds());});
      map.addLayer(currentLayer);
    }
    /* ---------- Labels ---------- */
    function addLabelsRecursive(layer){
      if(layer.getLayers){layer.getLayers().forEach(addLabelsRecursive);}  
      if(typeof layer.bindTooltip!=='function') return;
      const label=getLabel(layer);
      if(label && !layer.getTooltip()){
        layer.bindTooltip(label,{permanent:true,direction:'right',className:'tc-label',offset:[6,0]});
      }
    }
    function getLabel(layer){
      return layer?.feature?.properties?.name || layer.options?.title || layer.options?.name || ((layer.getPopup&&layer.getPopup())?(layer.getPopup().getContent().match(/<h2>(.*?)<\/h2>/i)||[])[1]:'');
    }
  </script>
</body>
</html>
