<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tropical Cyclone Explorer - Google Maps</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    #map { height: 100%; width: 100%; }
    .gm-style-iw { max-width: 300px; }
    /* Custom info window styling */
    .storm-info { font-size: 14px; line-height: 1.4; }
    .storm-info h3 { margin: 0 0 8px 0; font-weight: bold; }
    /* Time label styling */
    .storm-time-label {
      background: rgba(255, 255, 255, 0.9);
      padding: 2px 4px;
      border-radius: 3px;
      margin-top: 20px;
    }
  </style>
</head>
<body class="h-full w-full flex">
  <aside class="w-80 p-4 bg-gray-100 overflow-y-auto">
    <h1 class="text-2xl font-bold mb-4">Tropical Cyclones</h1>
    <input id="search" type="text" placeholder="Search storms…" class="mb-4 w-full p-2 border rounded" />
    <div class="mb-4 text-sm text-gray-600">
      <p>Click on a storm to load its track</p>
    </div>
    <ul id="storm-list" class="space-y-2"></ul>
  </aside>
  <main class="flex-1">
    <div id="map"></div>
  </main>
  
  <script>
    let map;
    let currentKmlLayer = null;
    let catalogue = [];
    let infoWindow;
    window.customMarkers = [];
    
    // Initialize map
    function initMap() {
      map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 20, lng: 0 },
        zoom: 3,
        mapTypeId: 'terrain',
        mapTypeControl: true,
        mapTypeControlOptions: {
          position: google.maps.ControlPosition.TOP_RIGHT
        }
      });
      
      infoWindow = new google.maps.InfoWindow();
      
      // Load the storm catalogue
      loadCatalogue();
    }
    
    // Load storm catalogue
    function loadCatalogue() {
      fetch('storms/storms.json')
        .then(r => r.ok ? r.json() : Promise.reject(r.status))
        .then(data => {
          catalogue = data;
          renderList(data, true);
        })
        .catch(code => alert(`storms.json error – HTTP ${code}`));
    }
    
    const listEl = document.getElementById('storm-list');
    const searchEl = document.getElementById('search');
    
    // Render storm list
    function renderList(arr, sortByYearDesc = false) {
      const sorted = arr.slice().sort((a, b) => {
        if (sortByYearDesc) {
          const yr = b.year - a.year;
          if (yr !== 0) return yr;
        }
        return a.id.localeCompare(b.id);
      });
      
      listEl.innerHTML = '';
      sorted.forEach(s => {
        const li = document.createElement('li');
        li.className = 'cursor-pointer hover:bg-blue-100 p-2 rounded transition-colors';
        li.innerHTML = `
          <div class="font-medium">${s.id} – ${s.name || 'Unnamed'}</div>
          <div class="text-sm text-gray-600">${s.year}</div>
        `;
        li.onclick = () => loadStorm(s);
        listEl.appendChild(li);
      });
    }
    
    // Search functionality
    searchEl.oninput = e => {
      const q = e.target.value.trim().toLowerCase();
      if (!q) {
        renderList(catalogue, true);
        return;
      }
      const filtered = catalogue.filter(s =>
        s.id.toLowerCase().includes(q) ||
        (s.name && s.name.toLowerCase().includes(q)) ||
        String(s.year).includes(q)
      );
      renderList(filtered, false);
    };
    
    // Load and display storm KML
    function loadStorm(storm) {
      // Show loading indicator
      showLoading(true);
      
      // Remove existing KML layer if any
      if (currentKmlLayer) {
        currentKmlLayer.setMap(null);
      }
      
      // Clear any existing custom markers
      if (window.customMarkers) {
        window.customMarkers.forEach(marker => marker.setMap(null));
      }
      window.customMarkers = [];
      
      // First, try to use Google's KmlLayer with properly hosted KML
      const baseUrl = 'https://conggao-cg.github.io/tc-explorer';
      const kmlUrl = storm.kml.startsWith('http') ? storm.kml : `${baseUrl}/${storm.kml}`;
      
      console.log('Loading KML from:', kmlUrl);
      
      // Create a proxy URL that serves the KML with fixed icon paths
      // This is faster than parsing the entire KML client-side
      loadKmlWithFixedIcons(storm, kmlUrl, baseUrl);
    }
    
    // Load KML using Google's optimized KmlLayer
    function loadKmlWithFixedIcons(storm, kmlUrl, baseUrl) {
      // For GitHub Pages, we need to ensure the KML has absolute URLs
      // Option 1: Direct load (works if KML already has absolute URLs)
      currentKmlLayer = new google.maps.KmlLayer({
        url: kmlUrl,
        map: map,
        preserveViewport: false,
        suppressInfoWindows: false,
        preserveViewport: false
      });
      
      let loadTimeout = setTimeout(() => {
        console.warn('KML loading timeout - trying alternative method');
        loadKmlAlternative(storm);
      }, 10000); // 10 second timeout
      
      google.maps.event.addListener(currentKmlLayer, 'status_changed', function() {
        clearTimeout(loadTimeout);
        const status = currentKmlLayer.getStatus();
        
        if (status === 'OK') {
          console.log('KML loaded successfully');
          showLoading(false);
          
          // Try to add time labels as overlay
          addTimeLabelsOverlay(storm);
        } else {
          console.error('KML loading error:', status);
          showLoading(false);
          
          if (status === 'DOCUMENT_NOT_FOUND') {
            alert('Error: KML file not found. Make sure GitHub Pages is enabled and the file exists.');
          } else if (status === 'FETCH_ERROR') {
            // Try alternative loading method
            loadKmlAlternative(storm);
          } else {
            alert(`Error loading storm data: ${status}\n\nTrying alternative method...`);
            loadKmlAlternative(storm);
          }
        }
      });
    }
    
    // Alternative loading method - simplified version
    function loadKmlAlternative(storm) {
      showLoading(true);
      
      fetch(storm.kml)
        .then(response => response.text())
        .then(kmlText => {
          // Quick parse for just the essentials
          const parser = new DOMParser();
          const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
          const placemarks = kmlDoc.getElementsByTagName('Placemark');
          const bounds = new google.maps.LatLngBounds();
          const positions = [];
          
          // Create simplified markers
          Array.from(placemarks).forEach((placemark, index) => {
            // Skip if too many points (performance)
            if (index % 3 !== 0 && placemarks.length > 100) return;
            
            const coordinates = placemark.getElementsByTagName('coordinates')[0];
            if (!coordinates) return;
            
            const coordText = coordinates.textContent.trim();
            const [lng, lat] = coordText.split(',').map(parseFloat);
            const position = new google.maps.LatLng(lat, lng);
            bounds.extend(position);
            positions.push(position);
            
            // Get time for label
            const when = placemark.getElementsByTagName('when')[0];
            const timeText = when ? formatTime(when.textContent) : '';
            
            // Create simple marker
            if (index % 6 === 0 || index === 0 || index === placemarks.length - 1) {
              const marker = new google.maps.Marker({
                position: position,
                map: map,
                icon: {
                  path: google.maps.SymbolPath.CIRCLE,
                  scale: 6,
                  fillColor: '#ff0000',
                  fillOpacity: 0.8,
                  strokeColor: '#ffffff',
                  strokeWeight: 2
                },
                title: timeText
              });
              
              // Add time label
              if (timeText) {
                const label = new google.maps.Marker({
                  position: position,
                  map: map,
                  icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 0
                  },
                  label: {
                    text: timeText,
                    color: '#000',
                    fontSize: '10px',
                    fontWeight: 'bold'
                  }
                });
                window.customMarkers.push(label);
              }
              
              window.customMarkers.push(marker);
            }
          });
          
          // Draw storm track
          if (positions.length > 1) {
            const stormPath = new google.maps.Polyline({
              path: positions,
              geodesic: true,
              strokeColor: '#FF0000',
              strokeOpacity: 0.8,
              strokeWeight: 2
            });
            stormPath.setMap(map);
            window.customMarkers.push(stormPath);
          }
          
          map.fitBounds(bounds);
          showLoading(false);
        })
        .catch(error => {
          console.error('Alternative loading failed:', error);
          showLoading(false);
          alert('Failed to load storm data. Please check the console for details.');
        });
    }
    
    // Add time labels as overlay (for successful KmlLayer loads)
    function addTimeLabelsOverlay(storm) {
      // This is a lightweight overlay just for time labels
      fetch(storm.kml)
        .then(response => response.text())
        .then(kmlText => {
          const parser = new DOMParser();
          const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
          const placemarks = kmlDoc.getElementsByTagName('Placemark');
          
          // Add time labels for key points only
          Array.from(placemarks).forEach((placemark, index) => {
            // Only label every 6 hours and first/last points
            if (index % 6 !== 0 && index !== 0 && index !== placemarks.length - 1) return;
            
            const coordinates = placemark.getElementsByTagName('coordinates')[0];
            if (!coordinates) return;
            
            const coordText = coordinates.textContent.trim();
            const [lng, lat] = coordText.split(',').map(parseFloat);
            
            const when = placemark.getElementsByTagName('when')[0];
            const timeText = when ? formatTime(when.textContent) : '';
            
            if (timeText) {
              const label = new google.maps.Marker({
                position: new google.maps.LatLng(lat, lng),
                map: map,
                icon: {
                  path: google.maps.SymbolPath.CIRCLE,
                  scale: 0
                },
                label: {
                  text: timeText,
                  color: '#000',
                  fontSize: '10px',
                  fontWeight: 'bold',
                  className: 'storm-time-label'
                },
                zIndex: 1000
              });
              window.customMarkers.push(label);
            }
          });
        })
        .catch(error => {
          console.warn('Could not add time labels:', error);
        });
    }
    
    // Show/hide loading indicator
    function showLoading(show) {
      let loadingEl = document.getElementById('loading-indicator');
      if (!loadingEl && show) {
        loadingEl = document.createElement('div');
        loadingEl.id = 'loading-indicator';
        loadingEl.className = 'fixed top-4 right-4 bg-white p-4 rounded shadow-lg z-50';
        loadingEl.innerHTML = `
          <div class="flex items-center">
            <svg class="animate-spin h-5 w-5 mr-3" viewBox="0 0 24 24">
              <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
              <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Loading storm data...
          </div>
        `;
        document.body.appendChild(loadingEl);
      } else if (loadingEl && !show) {
        loadingEl.remove();
      }
    }
    
    // Format time from ISO string
    function formatTime(isoString) {
      if (!isoString) return '';
      const date = new Date(isoString);
      const month = (date.getUTCMonth() + 1).toString().padStart(2, '0');
      const day = date.getUTCDate().toString().padStart(2, '0');
      const hours = date.getUTCHours().toString().padStart(2, '0');
      return `${month}/${day} ${hours}Z`;
    }
  </script>
  
  <!-- Load Google Maps API -->
  <!-- Replace YOUR_API_KEY_HERE with your actual Google Maps API key -->
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBX_YvYFsw9M3Q7wMFoL2QDh7dI_ASyAps&callback=initMap&libraries=visualization">
  </script>
</body>
</html>
